Конкурентність
Go надає конструкції для побудови конкурентності як чистину ядра мови програмування. Цей урок демонструє їх та дає приклади використання.

Автори Go
https://golang.org

* Goroutines

_goroutine_ - це легковагий потік виконання керований середовищем виконання Go.

	go f(x, y, z)

стартує нову goroutine що виконує

	f(x, y, z)

Обрахунок `f`, `x`, `y`, та `z` відбувається в поточній goroutine, а виконання `f` відбувається вже в новій.

Виронання goroutine відбувається в єдиному адресному просторі, тому доступ до смільної памʼяті має бути синхронізовано. Пакет [[/pkg/sync/][`sync`]] надає корисні примітиви для цього, проте вони не так часто потрібні, бо в Go вже існують прімітиви. (Докладніше на наступному слайді.)

.play concurrency/goroutines.go

* Канали

Канали це типізовані провідники через які можна передавати та отримувати значення за допомогою канального оператора, `<-`.

	ch <- v    // Відправляє значення v в канал ch.
	v := <-ch  // Отримуємо значення з каналу ch, та
	           // присвоюємо його змінній v.

(Данні рухаються в напрямку стрілки.)

Так само як словники та зрізи, канали мають бути створені перед використанням:

	ch := make(chan int)

За замовчуванням, відсилання та отримання блокують виконання поточної goroutine до готовності іншої сторони каналу. Це дає змогу goroutine синхронізуватися без явного використання локів або умовних змінних.

Цей приклад сумує значення в зрізі, розподіляючи роботу між двома goroutine.
Остаточний результат обчислюється щойно обидві goroutine закінчують свої підрахунки.

.play concurrency/channels.go

* Буферизовані канали

Канали можуть бути буферизовані. Для ініціалізації буферизованого каналу, передайте довжину буфера як другий аргумент до `make`:

	ch := make(chan int, 100)

Відсилання в буферизований канал блокується тільки коли буфер заповнений. Отримання блокується тільки коли буфер порожній.

Змініть приклад так, щоб переповнити буфер і подивіться що відбудеться.

.play concurrency/buffered-channels.go

* Range та Close

Посилальник може закрити канал, щоб вказати, що більше значень не буде відправлено. Отримувачі можуть перевірити, чи був канал закритий, присвоєнням другого параметра до виразу отримання: after

	v, ok := <-ch

`ok` буде `false` якщо більше немає значень для отримання і канал закритий.

Цикл `for`i`:=`range`c` отримує значення з каналу поки він не буде закритий.

*Примітка:* Тільки відсилальник повинен закривати канал, а не отримувач. Відсилання в закритий канал призведе до паніки.

*Ще*одна*примітка:* Канали не схожі на файли; ви зазвичай не потребуєте їх закривати. Закриття потрібне тільки коли отримувач повинен бути повідомлений, що більше значень не буде відправлено, наприклад для завершення циклу `range`.

.play concurrency/range-and-close.go

* Select

Вираз `select` дозволяє goroutine чекати на декілька операцій комунікації.

Вираз `select` блокується, поки один з випадків не може бути виконаний, а потім виконує цей випадок. Він вибирає один випадок випадково, якщо декілька випадків готові.

.play concurrency/select.go

* Вибір за замовчуванням

Випадок `default` в `select` виконується, якщо жоден інший випадок не готовий.

Використовуйте випадок `default` для спроби відсилання або отримання без блокування:

	select {
	case i := <-c:
		// виконується, якщо отримання з c не блокує
	default:
		// виконується, якщо отримання з c блокує
	}

.play concurrency/default-selection.go

* Вправа: Еквівалентні Бінарні Дерева

Може бути багато різних бінарних дерев з однаковою послідовністю значень, що зберігаються в них. Наприклад, тут два бінарних дерева, що зберігають послідовність 1, 1, 2, 3, 5, 8, 13.

.image /tour/static/img/tree.png

Функція для перевірки, чи два бінарних дерева зберігають однакову послідовність, досить складна у більшості мов. Ми використаємо конкурентність та канали Go для написання простого рішення.

Цей приклад використовує пакет `tree`, який визначає тип:

	type Tree struct {
		Left  *Tree
		Value int
		Right *Tree
	}


Опис продовжується на [[javascript:click('.next-page')][наступній сторінці]].

* Вправа: Еквівалентні Бінарні Дерева

*1.* Реалізуйте функцію `Walk`.

*2.* Протестуйте функцію `Walk`.

Функція `tree.New(k)` створює бінарне дерево з випадковою структурою (але завжди відсортованою), що зберігає значення `k`, `2k`, `3k`, ..., `10k`.

Створіть новий канал `ch` та запустіть walker:

	go Walk(tree.New(1), ch)

Тоді прочитайте та виведіть 10 значень з каналу. Це повинні бути числа 1, 2, 3, ..., 10.

*3.* Реалізуйте функцію `Same`, використовуючи `Walk` для визначення, чи зберігають `t1` та `t2` однакові значення.

*4.* Протестуйте функцію `Same`.

`Same(tree.New(1),`tree.New(1))` повинна повернути true, а `Same(tree.New(1),`tree.New(2))` повинна повернути false.

Документація для `Tree` можна знайти [[https://godoc.org/golang.org/x/tour/tree#Tree][тут]].

.play concurrency/exercise-equivalent-binary-trees.go

* sync.Mutex

We've seen how channels are great for communication among goroutines.

But what if we don't need communication? What if we just want to make sure only
one goroutine can access a variable at a time to avoid conflicts?

This concept is called _mutual_exclusion_, and the conventional name for the data structure that provides it is _mutex_.

Go's standard library provides mutual exclusion with
[[/pkg/sync/#Mutex][`sync.Mutex`]] and its two methods:

- `Lock`
- `Unlock`

We can define a block of code to be executed in mutual exclusion by surrounding it
with a call to `Lock` and `Unlock` as shown on the `Inc` method.

We can also use `defer` to ensure the mutex will be unlocked as in the `Value` method.

.play concurrency/mutex-counter.go

* Exercise: Web Crawler

In this exercise you'll use Go's concurrency features to parallelize a web crawler.

Modify the `Crawl` function to fetch URLs in parallel without fetching the same URL twice.

_Hint_: you can keep a cache of the URLs that have been fetched on a map, but maps alone are not
safe for concurrent use!

.play concurrency/exercise-web-crawler.go

* Where to Go from here...

#appengine: You can get started by
#appengine: [[/dl/][installing Go]].

#appengine: Once you have Go installed, the
The
[[/doc/][Go Documentation]] is a great place to
#appengine: continue.
start.
It contains references, tutorials, videos, and more.

To learn how to organize and work with Go code, read [[/doc/code][How to Write Go Code]].

If you need help with the standard library, see the [[/pkg/][package reference]]. For help with the language itself, you might be surprised to find the [[/ref/spec][Language Spec]] is quite readable.

To further explore Go's concurrency model, watch
[[https://www.youtube.com/watch?v=f6kdp27TYZs][Go Concurrency Patterns]]
([[/talks/2012/concurrency.slide][slides]])
and
[[https://www.youtube.com/watch?v=QDDwwePbDtw][Advanced Go Concurrency Patterns]]
([[/talks/2013/advconc.slide][slides]])
and read the
[[/doc/codewalk/sharemem/][Share Memory by Communicating]]
codewalk.

To get started writing web applications, watch
[[https://vimeo.com/53221558][A simple programming environment]]
([[/talks/2012/simple.slide][slides]])
and read the
[[/doc/articles/wiki/][Writing Web Applications]] tutorial.

The [[/doc/codewalk/functions/][First Class Functions in Go]] codewalk gives an interesting perspective on Go's function types.

The [[/blog/][Go Blog]] has a large archive of informative Go articles.

Visit [[/][the Go home page]] for more.

