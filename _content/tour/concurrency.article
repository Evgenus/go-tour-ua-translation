Конкурентність
Go надає конструкції для побудови конкурентності як чистину ядра мови програмування. Цей урок демонструє їх та дає приклади використання.

Автори Go
https://golang.org

* Goroutines

_goroutine_ - це легковагий потік керований середовищем виконання Go.

	go f(x, y, z)

стартує нову goroutine що виконує

	f(x, y, z)

Обрахунок `f`, `x`, `y`, та `z` відбувається в поточній goroutine, а виконання `f` відбувається вже в новій.

Виконання goroutine відбувається в єдиному адресному просторі, тому доступ до смільної памʼяті має бути синхронізовано. Пакет [[/pkg/sync/][`sync`]] надає корисні примітиви для цього, проте вони не так часто потрібні, бо в Go вже існують прімітиви. (Докладніше на наступному слайді.)

.play concurrency/goroutines.go

* Канали

Канали це типізовані провідники через які можна передавати та отримувати значення за допомогою канального оператора, `<-`.

	ch <- v    // Відправляє значення v в канал ch.
	v := <-ch  // Отримуємо значення з каналу ch, та
	           // присвоюємо його змінній v.

(Данні рухаються в напрямку стрілки.)

Так само як словники та зрізи, канали мають бути створені перед використанням:

	ch := make(chan int)

За замовчуванням, відсилання та отримання блокують виконання поточної goroutine до готовності іншої сторони каналу. Це дає змогу goroutine синхронізуватися без явного використання локів або умовних змінних.

Цей приклад сумує значення в зрізі, розподіляючи роботу між двома goroutine.
Остаточний результат обчислюється щойно обидві goroutine закінчують свої підрахунки.

.play concurrency/channels.go

* Буферизовані канали

Канали можуть бути буферизовані. Для ініціалізації буферизованого каналу, передайте довжину буфера як другий аргумент до `make`:

	ch := make(chan int, 100)

Відсилання в буферизований канал блокується тільки коли буфер заповнений. Отримання блокується тільки коли буфер порожній.

Змініть приклад так, щоб переповнити буфер і подивіться що відбудеться.

.play concurrency/buffered-channels.go

* Range та Close

Посилальник може закрити канал, щоб вказати, що більше значень не буде відправлено. Отримувачі можуть перевірити, чи був канал закритий, присвоєнням другого параметра до виразу отримання: after

	v, ok := <-ch

`ok` буде `false` якщо більше немає значень для отримання і канал закритий.

Цикл `for`i`:=`range`c` отримує значення з каналу поки він не буде закритий.

*Примітка:* Тільки відсилальник повинен закривати канал, а не отримувач. Відсилання в закритий канал призведе до паніки.

*Ще*одна*примітка:* Канали не схожі на файли; ви зазвичай не потребуєте їх закривати. Закриття потрібне тільки коли отримувач повинен бути повідомлений, що більше значень не буде відправлено, наприклад для завершення циклу `range`.

.play concurrency/range-and-close.go

* Select

Вираз `select` дозволяє goroutine чекати на декілька операцій комунікації.

Вираз `select` блокується, поки один з випадків не може бути виконаний, а потім виконує цей випадок. Він вибирає один випадок випадково, якщо декілька випадків готові.

.play concurrency/select.go

* Вибір за замовчуванням

Випадок `default` в `select` виконується, якщо жоден інший випадок не готовий.

Використовуйте випадок `default` для спроби відсилання або отримання без блокування:

	select {
	case i := <-c:
		// виконується, якщо отримання з c не блокує
	default:
		// виконується, якщо отримання з c блокує
	}

.play concurrency/default-selection.go

* Вправа: Еквівалентні Бінарні Дерева

Може бути багато різних бінарних дерев з однаковою послідовністю значень, що зберігаються в них. Наприклад, тут два бінарних дерева, що зберігають послідовність 1, 1, 2, 3, 5, 8, 13.

.image /tour/static/img/tree.png

Функція для перевірки, чи два бінарних дерева зберігають однакову послідовність, досить складна у більшості мов. Ми використаємо конкурентність та канали Go для написання простого рішення.

Цей приклад використовує пакет `tree`, який визначає тип:

	type Tree struct {
		Left  *Tree
		Value int
		Right *Tree
	}


Опис продовжується на [[javascript:click('.next-page')][наступній сторінці]].

* Вправа: Еквівалентні Бінарні Дерева

*1.* Реалізуйте функцію `Walk`.

*2.* Протестуйте функцію `Walk`.

Функція `tree.New(k)` створює бінарне дерево з випадковою структурою (але завжди відсортованою), що зберігає значення `k`, `2k`, `3k`, ..., `10k`.

Створіть новий канал `ch` та запустіть walker:

	go Walk(tree.New(1), ch)

Тоді прочитайте та виведіть 10 значень з каналу. Це повинні бути числа 1, 2, 3, ..., 10.

*3.* Реалізуйте функцію `Same`, використовуючи `Walk` для визначення, чи зберігають `t1` та `t2` однакові значення.

*4.* Протестуйте функцію `Same`.

`Same(tree.New(1),`tree.New(1))` повинна повернути true, а `Same(tree.New(1),`tree.New(2))` повинна повернути false.

Документація для `Tree` можна знайти [[https://godoc.org/golang.org/x/tour/tree#Tree][тут]].

.play concurrency/exercise-equivalent-binary-trees.go

* sync.Mutex

Ми бачили, як канали чудово працюють для спілкування між goroutine.

А що, якщо нам не потрібне спілкування? Що, якщо ми просто хочемо, щоб тільки
одна goroutine могла одночасно отримати доступ до змінної, щоб уникнути конфліктів?

Ця концепція називається _взаємовиключенням_, а звичайна назва для структури даних, яка надає її, - _mutex_ (мʼютекс).

Стандартна бібліотека Go надає взаємовиключення за допомогою структури
[[/pkg/sync/#Mutex][`sync.Mutex`]] та її двох методів:

- `Lock`
- `Unlock`

Ми можемо визначити блок коду, який буде виконуватися з взаємовиключенням, огорнувши
його викликом `Lock` та `Unlock`, як показано в методі `Inc`.

Ми також можемо використовувати `defer`, щоб впевнитися, що мʼютекс буде розблокований, як в методі `Value`.

.play concurrency/mutex-counter.go

* Вправа: Веб-краулер

В цій вправі ви використаєте можливості конкурентності Go для паралельного веб-краулера.

Змініть функцію `Crawl` так, щоб вона паралельно завантажувала URL-адреси без повторного завантаження однієї та тієї ж URL-адреси.

_Підказка_: ви можете зберігати кеш URL-адрес, які вже були завантажені, в словнику, але словники самі по собі
не є безпечними для конкурентного використання!

.play concurrency/exercise-web-crawler.go

* Що робити далі...

#appengine: Ви можете почати з
#appengine: [[/dl/][встановлення Go]].

#appengine: Щойно ви встановите Go, ви можете
[[/doc/][документація Go]] - чудове місце для
#appengine: продовження.
починати.
Вона містить посилання, посібники, відео та багато іншого.

Для того, щоб дізнатися, як організувати та працювати з кодом Go, прочитайте [[/doc/code][Як писати код Go]].

Якщо вам потрібна допомога зі стандартною бібліотекою, перегляньте [[/pkg/][посібник по пакетам]]. Якщо вам потрібна допомога з самою мовою, ви можете бути здивовані, коли зрозумієте, що [[/ref/spec][Специфікація мови]] досить зрозуміла.

To further explore Go's concurrency model, watch
Для подальшого ознайомлення з моделлю конкурентності Go, дивіться
[[https://www.youtube.com/watch?v=f6kdp27TYZs][Go Concurrency Patterns]]
([[/talks/2012/concurrency.slide][slides]])
та
[[https://www.youtube.com/watch?v=QDDwwePbDtw][Advanced Go Concurrency Patterns]]
([[/talks/2013/advconc.slide][slides]])
та прочитайте
[[/doc/codewalk/sharemem/][Share Memory by Communicating]]
огляд коду.

To get started writing web applications, watch
Для початку розробки веб-додатків, дивіться
[[https://vimeo.com/53221558][A simple programming environment]]
([[/talks/2012/simple.slide][slides]])
та прочитайте
[[/doc/articles/wiki/][Writing Web Applications]] посібник.

[[/doc/codewalk/functions/][First Class Functions in Go]] - це цікавий огляд типів функцій Go.

The [[/blog/][Go Blog]] has a large archive of informative Go articles.
[[/blog/][Go Blog]] містить великий архів інформативних статей про Go.

Відвідайте [[/][домашню сторінку Go]] для отримання додаткової інформації.
